# 03B - Database Management Basics

Applications that provide valuable services typically persist some aspect of state such as user submitted data or session information. However, persisting state can come with significant maintenance costs in guaranteeing availability and data integrity.  
Schema management is one such area that often proves to be costly. In the lifespan of a software service, the content and structure of how state is represented can evolve. For example, a US based service may need to begin supporting Asian users with names that require Unicode. Worse yet, your service may need to support completely different address schema resulting in having to move out user addresses into a separate table. How payment information is persisted can completely change as well if your service begins supporting Google Pay or AliPay. Users' needs  inevitably change and your software must evolve to meet those changing needs. 

On its own, schema upgrade and maintenance seems trivial, but when it's performed on a live service with active users it suddenly becomes a trecherous exercise. Does the service need to be taken down during the upgrade? What happens when the upgrade fails or corrupts the only instance of the database you have? 

This step will introduce a database migration tool called `alembic` to the API. Database migration is a technique for incrementally managing database schemas using code and relying on software to handle the actual manipulation of the tables. The migration tool is used to generate migration code based on modifications to your ORM classes and perform upgrades and downgrades to the database schema.

### Parts

- `alembic` [[docs](https://alembic.sqlalchemy.org/en/latest/)]
- `flask-migrate` [docs](https://flask-migrate.readthedocs.io/)]
- `flask-sqlalchemy`  [[docs](https://flask-sqlalchemy.palletsprojects.com/)]

## Challenge

The goal of this challenge is to perform local database migrations as practice in preparation for setting up a database instance in the cloud. Using the starter code create and perform migrations agains a local SQLite database. Check in your migration files generated in this process in git.

Try to get through the challenge pretending that this is for a live service and you're performing upgrades during a maintenance window. 

### Step 1 - Setup

Install `flask-migrate` and `flask-sqlalchemy` from pypi and initialize the "repo" (inside starter folder) using the following command:

`flask db init`

The initial ORM models have been set up for you in `models.py` where it will get picked up automatically when creating your first migration:

`flask db migrate -m "initial migration"`

The migration script created can be found in `starter/migrations/versions` and it can be applied to your database with the following command:

`flask db upgrade`

If you have not created your local SQLite database file yet, this command would have created it for you. Using any SQLite DB viewer app (such as [SQLite Browser](https://sqlitebrowser.org/)) confirm that tables reflecting the ORM models were created.

### Step 2 - Schema Migration

Update the User ORM model to have the field `fullname` and create a migration script using `flask db migrate`. They should look pretty much exacly like the following:

```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('fullname', sa.String(), nullable=True))
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'fullname')
    # ### end Alembic commands ###
```

Modify `downgrade()` like the following:

```python
def downgrade():
    # https://stackoverflow.com/questions/30394222/why-flask-migrate-cannot-upgrade-when-drop-column
    with op.batch_alter_table('users') as batch_op:
        batch_op.drop_column('fullname')
```

This is necessary because SQLite does not support dropping columns the way Alembic implements it by default. The reason why we're making sure that this works first is because if `upgrade()` fails half way through, you will need to perform `downgrade()` before retrying `upgrade()`.

Make sure to update `from_dict()` and `to_dict()` to reflect the new columns in each step. 

Now that the schema is ready, you will create an entry in the local database using the following CLI command implemented for this challenge in `init_local()` in `app.py`:

`flask init_db`

Confirm that the test user has been initialized in the database using a browser.

### Step 3 - Data Migration

Now modify the User ORM model to have fields `first_name` and `last_name` and create a migration script using `flask db migrate`. They should look pretty much exacly like the following:

```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('first_name', sa.String(), nullable=True))
    op.add_column('users', sa.Column('last_name', sa.String(), nullable=True))
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'last_name')
    op.drop_column('users', 'first_name')
    # ### end Alembic commands ###
```

First, modify `downgrade()` like in Step 2. Next, modify `upgrade()` like the following:

```python
from sqlalchemy.sql import table

def upgrade():
    op.add_column('users', sa.Column('first_name', sa.String(), nullable=True))
    op.add_column('users', sa.Column('last_name', sa.String(), nullable=True))

    connection = op.get_bind()

    t_users = table(
        'users',
        sa.Column('username'),
        sa.Column('fullname'),
        sa.Column('first_name'),
        sa.Column('last_name'),
    )

    # SELECT username, fullname FROM users
    results = connection.execute(sa.select([
        t_users.c.username,
        t_users.c.fullname,
    ])).fetchall()

	# UPDATE users SET first_name = x, last_name = y WHERE username = z
    for username, fullname in results:
        first_name, last_name = fullname.rsplit(' ', 1)
        connection.execute(
            t_users
                .update()
                .where(t_users.c.username == username)
                .values(
                    last_name=last_name,
                    first_name=first_name,
                )
        )
```

This new upgrade function queries the users table and iteratively updates each row with the first and last name generated by splitting the fullname.

Now that the migration is updated to also include your data migration, perform the upgrade with `flask db upgrade`. Confirm using the DB viewer that both the schema migration and data migration has been performed.

Bonus: perform `flask db downgrade` then `flask db upgrade` to see that different revisions of the database schema can be applied.

### Step 4 - Changing a Column Type

Using what you learned in the previous steps, modify the `user_tier` field from String to Integer. The following function should be used to convert the string values into integers:

```python
def convert_tier_to_level(user_tier):
	TIER_MAPPING = {
		'noob': 0,
		'beginner': 1,
		'intermediate': 2,
		'advanced': 3,
		'god': 4
	}

	try:
		return TIER_MAPPING[user_tier]
	except KeyError:
		return -1
```

Hint: You'll want to do the following:

1. Create a new temporary Integer column and set its value using `convert_tier_to_level()`
2. Drop user_tier column (or rename it e.g. user_tier_legacy)
3. Rename the temporary column as user_tier using `op.alter_column()`

Feel free to break up the migration into multiple migration steps.